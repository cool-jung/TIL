<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>홀수</title>
    
    
</head>
<body>

    

<script>

//오름차순으로 정렬이 된 두 배열이 주어지면 두 배열을 오름차순으로 합쳐 출력하는 프로그램

// 첫번째 줄에 첫번째 배열의 크기 N(1<=N<=100)이 주어집니다.
// 두번째 줄에 N개의 배열 원소가 오름차순으로 주어집니다.
// 세번째 줄에 두번째 배열의 크기 M(1<=M<=100)이 주어집니다.
// 네번째 줄에 M개의 배열 원소가 오름차순으로 주어집니다.
// 각 리스트의 원소는 INT형 변수의 크기를 넘지 않습니다.

//출력 설명: 오름차순으로 정렬된 배열을 출력합니다.
// 입력 : 
// 3
// 1 3 5
// 5
// 2 3 6 7 9

// 출력 :
// 1 2 3 3 5 6 7 9

function solution(arr1, arr2){
    let answer=[]; //answer의 결과 값을 배열로 받기 위해
    let n = arr1.length;    //n개의 배열 갯수
    let m = arr2.length;    //m개의 배열 갯수
    let p1=p2=0;    //p1,p2를 two pointers로 0번째 인덱스로 가르키기 위해서 0으로 초기화
    while(p1<n && p2<m){ //p1이 n보다 작을때까지와 p2가 m보다 작을때 까지 반복
        if(arr1[p1]<=arr2[p2]) answer.push(arr1[p1++]); //arr1[p1]값이 arr2[p2]의 값보다 작거나 같을때 answer의 배열에 푸시하고 인덱스를 증가 시킨다.
        else answer.push(arr2[p2++]);   //아닐경우 arr2[p2]의 값을 answer의 배열에 푸시하고 인덱스를 증가 시킨다.
    }   
    // 밑은 비교가 끝나고 나머지 값들 처리
    while(p1<n)answer.push(arr1[p1++]); //나머지 p1이 아직도 남았을때 n보다 작으면 푸시
    while(p2<m)answer.push(arr2[p2++]); //나머지 p2이 아직도 남았을때 m보다 작으면 푸시

    return answer; 

}

let a =[1,3,5];
let b =[2,3,6,7,9];
console.log(solution(a,b));



</script>


</body>
</html>